{"ast":null,"code":"/*!\n * chartjs-plugin-streaming v1.8.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2019 Akihiko Kusanagi\n * Released under the MIT license\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('chart.js'), require('moment')) : typeof define === 'function' && define.amd ? define(['chart.js', 'moment'], factory) : (global = global || self, global.ChartStreaming = factory(global.Chart, global.moment));\n})(this, function (Chart, moment) {\n  'use strict';\n\n  Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;\n  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;\n  var helpers = Chart.helpers;\n\n  var cancelAnimFrame = function () {\n    if (typeof window !== 'undefined') {\n      return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {\n        return window.clearTimeout(id);\n      };\n    }\n  }();\n\n  var StreamingHelper = {\n    startFrameRefreshTimer: function (context, func) {\n      if (!context.frameRequestID) {\n        var frameRefresh = function () {\n          func();\n          context.frameRequestID = helpers.requestAnimFrame.call(window, frameRefresh);\n        };\n\n        context.frameRequestID = helpers.requestAnimFrame.call(window, frameRefresh);\n      }\n    },\n    stopFrameRefreshTimer: function (context) {\n      var frameRequestID = context.frameRequestID;\n\n      if (frameRequestID) {\n        cancelAnimFrame.call(window, frameRequestID);\n        delete context.frameRequestID;\n      }\n    }\n  };\n  var helpers$1 = Chart.helpers;\n  var canvasHelpers = helpers$1.canvas;\n  var scaleService = Chart.scaleService;\n  var TimeScale = scaleService.getScaleConstructor('time');\n\n  scaleService.getScaleConstructor = function (type) {\n    // For backwards compatibility\n    if (type === 'time') {\n      type = 'realtime';\n    }\n\n    return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n  }; // For Chart.js 2.7.x backward compatibility\n\n\n  var defaultAdapter = {\n    // Ported from Chart.js 2.8.0-rc.1 35273ee\n    parse: function (value, format) {\n      if (typeof value === 'string' && typeof format === 'string') {\n        value = moment(value, format);\n      } else if (!(value instanceof moment)) {\n        value = moment(value);\n      }\n\n      return value.isValid() ? value.valueOf() : null;\n    }\n  }; // Ported from Chart.js 2.8.0-rc.1 35273ee. Modified for Chart.js 2.7.x backward compatibility.\n\n  function toTimestamp(scale, input) {\n    var adapter = scale._adapter || defaultAdapter;\n    var options = scale.options.time;\n    var parser = options.parser;\n    var format = parser || options.format;\n    var value = input;\n\n    if (typeof parser === 'function') {\n      value = parser(value);\n    } // Only parse if its not a timestamp already\n\n\n    if (typeof value !== 'number' && !(value instanceof Number) || !isFinite(value)) {\n      value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);\n    }\n\n    if (value !== null) {\n      return +value;\n    } // Labels are in an incompatible format and no `parser` has been provided.\n    // The user might still use the deprecated `format` option for parsing.\n\n\n    if (!parser && typeof format === 'function') {\n      value = format(input); // `format` could return something else than a timestamp, if so, parse it\n\n      if (typeof value !== 'number' && !(value instanceof Number) || !isFinite(value)) {\n        value = adapter.parse(value);\n      }\n    }\n\n    return value;\n  } // Ported from Chart.js 2.8.0-rc.1 35273ee\n\n\n  function parse(scale, input) {\n    if (helpers$1.isNullOrUndef(input)) {\n      return null;\n    }\n\n    var options = scale.options.time;\n    var value = toTimestamp(scale, scale.getRightValue(input));\n\n    if (value === null) {\n      return value;\n    }\n\n    if (options.round) {\n      value = +scale._adapter.startOf(value, options.round);\n    }\n\n    return value;\n  }\n\n  function resolveOption(scale, key) {\n    var realtimeOpts = scale.options.realtime;\n    var streamingOpts = scale.chart.options.plugins.streaming;\n    return helpers$1.valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n  }\n\n  var datasetPropertyKeys = ['pointBackgroundColor', 'pointBorderColor', 'pointBorderWidth', 'pointRadius', 'pointRotation', 'pointStyle', 'pointHitRadius', 'pointHoverBackgroundColor', 'pointHoverBorderColor', 'pointHoverBorderWidth', 'pointHoverRadius', 'backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'radius', 'rotation'];\n\n  function refreshData(scale) {\n    var chart = scale.chart;\n    var id = scale.id;\n    var duration = resolveOption(scale, 'duration');\n    var delay = resolveOption(scale, 'delay');\n    var ttl = resolveOption(scale, 'ttl');\n    var pause = resolveOption(scale, 'pause');\n    var onRefresh = resolveOption(scale, 'onRefresh');\n    var max = scale.max;\n    var min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n    var meta, data, length, i, start, count, removalRange;\n\n    if (onRefresh) {\n      onRefresh(chart);\n    } // Remove old data\n\n\n    chart.data.datasets.forEach(function (dataset, datasetIndex) {\n      meta = chart.getDatasetMeta(datasetIndex);\n\n      if (id === meta.xAxisID || id === meta.yAxisID) {\n        data = dataset.data;\n        length = data.length;\n\n        if (pause) {\n          // If the scale is paused, preserve the visible data points\n          for (i = 0; i < length; ++i) {\n            if (!(scale._getTimeForIndex(i, datasetIndex) < max)) {\n              break;\n            }\n          }\n\n          start = i + 2;\n        } else {\n          start = 0;\n        }\n\n        for (i = start; i < length; ++i) {\n          if (!(scale._getTimeForIndex(i, datasetIndex) <= min)) {\n            break;\n          }\n        }\n\n        count = i - start;\n\n        if (isNaN(ttl)) {\n          // Keep the last two data points outside the range not to affect the existing bezier curve\n          count = Math.max(count - 2, 0);\n        }\n\n        data.splice(start, count);\n        datasetPropertyKeys.forEach(function (key) {\n          if (dataset.hasOwnProperty(key) && helpers$1.isArray(dataset[key])) {\n            dataset[key].splice(start, count);\n          }\n        });\n        helpers$1.each(dataset.datalabels, function (value) {\n          if (helpers$1.isArray(value)) {\n            value.splice(start, count);\n          }\n        });\n\n        if (typeof data[0] !== 'object') {\n          removalRange = {\n            start: start,\n            count: count\n          };\n        }\n      }\n    });\n\n    if (removalRange) {\n      chart.data.labels.splice(removalRange.start, removalRange.count);\n    }\n\n    chart.update({\n      preservation: true\n    });\n  }\n\n  function stopDataRefreshTimer(scale) {\n    var realtime = scale.realtime;\n    var refreshTimerID = realtime.refreshTimerID;\n\n    if (refreshTimerID) {\n      clearInterval(refreshTimerID);\n      delete realtime.refreshTimerID;\n      delete realtime.refreshInterval;\n    }\n  }\n\n  function startDataRefreshTimer(scale) {\n    var realtime = scale.realtime;\n    var interval = resolveOption(scale, 'refresh');\n    realtime.refreshTimerID = setInterval(function () {\n      var newInterval = resolveOption(scale, 'refresh');\n      refreshData(scale);\n\n      if (realtime.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(scale);\n        startDataRefreshTimer(scale);\n      }\n    }, interval);\n    realtime.refreshInterval = interval;\n  }\n\n  var transitionKeys = {\n    x: {\n      data: ['x', 'controlPointPreviousX', 'controlPointNextX'],\n      dataset: ['x'],\n      tooltip: ['x', 'caretX']\n    },\n    y: {\n      data: ['y', 'controlPointPreviousY', 'controlPointNextY'],\n      dataset: ['y'],\n      tooltip: ['y', 'caretY']\n    }\n  };\n\n  function transition(element, keys, translate) {\n    var start = element._start || {};\n    var view = element._view || {};\n    var model = element._model || {};\n    var i, ilen;\n\n    for (i = 0, ilen = keys.length; i < ilen; ++i) {\n      var key = keys[i];\n\n      if (start.hasOwnProperty(key)) {\n        start[key] -= translate;\n      }\n\n      if (view.hasOwnProperty(key) && view !== start) {\n        view[key] -= translate;\n      }\n\n      if (model.hasOwnProperty(key) && model !== view) {\n        model[key] -= translate;\n      }\n    }\n  }\n\n  function scroll(scale) {\n    var chart = scale.chart;\n    var realtime = scale.realtime;\n    var duration = resolveOption(scale, 'duration');\n    var delay = resolveOption(scale, 'delay');\n    var id = scale.id;\n    var tooltip = chart.tooltip;\n    var activeTooltip = tooltip._active;\n    var now = Date.now();\n    var length, keys, offset, meta, elements, i, ilen;\n\n    if (scale.isHorizontal()) {\n      length = scale.width;\n      keys = transitionKeys.x;\n    } else {\n      length = scale.height;\n      keys = transitionKeys.y;\n    }\n\n    offset = length * (now - realtime.head) / duration;\n\n    if (scale.options.ticks.reverse) {\n      offset = -offset;\n    } // Shift all the elements leftward or upward\n\n\n    helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {\n      meta = chart.getDatasetMeta(datasetIndex);\n\n      if (id === meta.xAxisID || id === meta.yAxisID) {\n        elements = meta.data || [];\n\n        for (i = 0, ilen = elements.length; i < ilen; ++i) {\n          transition(elements[i], keys.data, offset);\n        }\n\n        if (meta.dataset) {\n          transition(meta.dataset, keys.dataset, offset);\n        }\n      }\n    }); // Shift tooltip leftward or upward\n\n    if (activeTooltip && activeTooltip[0]) {\n      meta = chart.getDatasetMeta(activeTooltip[0]._datasetIndex);\n\n      if (id === meta.xAxisID || id === meta.yAxisID) {\n        transition(tooltip, keys.tooltip, offset);\n      }\n    }\n\n    scale.max = scale._table[1].time = now - delay;\n    scale.min = scale._table[0].time = scale.max - duration;\n    realtime.head = now;\n  }\n\n  var defaultConfig = {\n    position: 'bottom',\n    distribution: 'linear',\n    bounds: 'data',\n    adapters: {},\n    time: {\n      parser: false,\n      // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n      format: false,\n      // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n      unit: false,\n      // false == automatic or override with week, month, year, etc.\n      round: false,\n      // none, or override with week, month, year, etc.\n      displayFormat: false,\n      // DEPRECATED\n      isoWeekday: false,\n      // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n      minUnit: 'millisecond',\n      // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n      displayFormats: {\n        millisecond: 'h:mm:ss.SSS a',\n        second: 'h:mm:ss a',\n        minute: 'h:mm a',\n        hour: 'hA',\n        day: 'MMM D',\n        week: 'll',\n        month: 'MMM YYYY',\n        quarter: '[Q]Q - YYYY',\n        year: 'YYYY'\n      }\n    },\n    realtime: {},\n    ticks: {\n      autoSkip: false,\n      source: 'auto',\n      major: {\n        enabled: true\n      }\n    }\n  };\n  var RealTimeScale = TimeScale.extend({\n    initialize: function () {\n      var me = this;\n      TimeScale.prototype.initialize.apply(me, arguments); // For backwards compatibility\n\n      if (me.options.type === 'time' && !me.chart.options.plugins.streaming) {\n        return;\n      }\n\n      me.realtime = me.realtime || {};\n      startDataRefreshTimer(me);\n    },\n    update: function () {\n      var me = this;\n      var realtime = me.realtime; // For backwards compatibility\n\n      if (me.options.type === 'time' && !me.chart.options.plugins.streaming) {\n        return TimeScale.prototype.update.apply(me, arguments);\n      }\n\n      if (resolveOption(me, 'pause')) {\n        StreamingHelper.stopFrameRefreshTimer(realtime);\n      } else {\n        StreamingHelper.startFrameRefreshTimer(realtime, function () {\n          scroll(me);\n        });\n        realtime.head = Date.now();\n      }\n\n      return TimeScale.prototype.update.apply(me, arguments);\n    },\n    buildTicks: function () {\n      var me = this;\n      var options = me.options; // For backwards compatibility\n\n      if (options.type === 'time' && !me.chart.options.plugins.streaming) {\n        return TimeScale.prototype.buildTicks.apply(me, arguments);\n      }\n\n      var timeOpts = options.time;\n      var majorTicksOpts = options.ticks.major;\n      var duration = resolveOption(me, 'duration');\n      var delay = resolveOption(me, 'delay');\n      var refresh = resolveOption(me, 'refresh');\n      var bounds = options.bounds;\n      var distribution = options.distribution;\n      var offset = options.offset;\n      var minTime = timeOpts.min;\n      var maxTime = timeOpts.max;\n      var majorEnabled = majorTicksOpts.enabled;\n      var max = me.realtime.head - delay;\n      var min = max - duration;\n      var maxArray = [max + refresh, max];\n      var ticks;\n      options.bounds = undefined;\n      options.distribution = 'linear';\n      options.offset = false;\n      timeOpts.min = -1e15;\n      timeOpts.max = 1e15;\n      majorTicksOpts.enabled = true;\n      Object.defineProperty(me, 'min', {\n        get: function () {\n          return min;\n        },\n        set: helpers$1.noop\n      });\n      Object.defineProperty(me, 'max', {\n        get: function () {\n          return maxArray.shift();\n        },\n        set: helpers$1.noop\n      });\n      ticks = TimeScale.prototype.buildTicks.apply(me, arguments);\n      delete me.min;\n      delete me.max;\n      me.min = min;\n      me.max = max;\n      options.bounds = bounds;\n      options.distribution = distribution;\n      options.offset = offset;\n      timeOpts.min = minTime;\n      timeOpts.max = maxTime;\n      majorTicksOpts.enabled = majorEnabled;\n      me._table = [{\n        time: min,\n        pos: 0\n      }, {\n        time: max,\n        pos: 1\n      }];\n      return ticks;\n    },\n    fit: function () {\n      var me = this;\n      var options = me.options;\n      TimeScale.prototype.fit.apply(me, arguments); // For backwards compatibility\n\n      if (options.type === 'time' && !me.chart.options.plugins.streaming) {\n        return;\n      }\n\n      if (options.ticks.display && options.display && me.isHorizontal()) {\n        me.paddingLeft = 3;\n        me.paddingRight = 3;\n        me.handleMargins();\n      }\n    },\n    draw: function (chartArea) {\n      var me = this;\n      var chart = me.chart; // For backwards compatibility\n\n      if (me.options.type === 'time' && !chart.options.plugins.streaming) {\n        TimeScale.prototype.draw.apply(me, arguments);\n        return;\n      }\n\n      var context = me.ctx;\n      var clipArea = me.isHorizontal() ? {\n        left: chartArea.left,\n        top: 0,\n        right: chartArea.right,\n        bottom: chart.height\n      } : {\n        left: 0,\n        top: chartArea.top,\n        right: chart.width,\n        bottom: chartArea.bottom\n      }; // Clip and draw the scale\n\n      canvasHelpers.clipArea(context, clipArea);\n      TimeScale.prototype.draw.apply(me, arguments);\n      canvasHelpers.unclipArea(context);\n    },\n    destroy: function () {\n      var me = this; // For backwards compatibility\n\n      if (me.options.type === 'time' && !me.chart.options.plugins.streaming) {\n        return;\n      }\n\n      StreamingHelper.stopFrameRefreshTimer(me.realtime);\n      stopDataRefreshTimer(me);\n    },\n\n    /*\n     * @private\n     */\n    _getTimeForIndex: function (index, datasetIndex) {\n      var me = this;\n      var timestamps = me._timestamps;\n      var time = timestamps.datasets[datasetIndex][index];\n      var value;\n\n      if (helpers$1.isNullOrUndef(time)) {\n        value = me.chart.data.datasets[datasetIndex].data[index];\n\n        if (helpers$1.isObject(value)) {\n          time = parse(me, value);\n        } else {\n          time = parse(me, timestamps.labels[index]);\n        }\n      }\n\n      return time;\n    }\n  });\n  scaleService.registerScaleType('realtime', RealTimeScale, defaultConfig);\n  var helpers$2 = Chart.helpers;\n  var canvasHelpers$1 = helpers$2.canvas;\n  Chart.defaults.global.plugins.streaming = {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  };\n  /**\n   * Update the chart keeping the current animation but suppressing a new one\n   * @param {object} config - animation options\n   */\n\n  function update(config) {\n    var me = this;\n    var preservation = config && config.preservation;\n    var tooltip, lastActive, tooltipLastActive, lastMouseEvent;\n\n    if (preservation) {\n      tooltip = me.tooltip;\n      lastActive = me.lastActive;\n      tooltipLastActive = tooltip._lastActive;\n      me._bufferedRender = true;\n    }\n\n    Chart.prototype.update.apply(me, arguments);\n\n    if (preservation) {\n      me._bufferedRender = false;\n      me._bufferedRequest = null;\n      me.lastActive = lastActive;\n      tooltip._lastActive = tooltipLastActive;\n\n      if (me.animating) {\n        // If the chart is animating, keep it until the duration is over\n        Chart.animationService.animations.forEach(function (animation) {\n          if (animation.chart === me) {\n            me.render({\n              duration: (animation.numSteps - animation.currentStep) * 16.66\n            });\n          }\n        });\n      } else {\n        // If the chart is not animating, make sure that all elements are at the final positions\n        me.data.datasets.forEach(function (dataset, datasetIndex) {\n          me.getDatasetMeta(datasetIndex).controller.transition(1);\n        });\n      }\n\n      if (tooltip._active) {\n        tooltip.update(true);\n      }\n\n      lastMouseEvent = me.streaming.lastMouseEvent;\n\n      if (lastMouseEvent) {\n        me.eventHandler(lastMouseEvent);\n      }\n    }\n  } // Draw chart at frameRate\n\n\n  function drawChart(chart) {\n    var streaming = chart.streaming;\n    var frameRate = chart.options.plugins.streaming.frameRate;\n    var frameDuration = 1000 / (Math.max(frameRate, 0) || 30);\n    var next = streaming.lastDrawn + frameDuration || 0;\n    var now = Date.now();\n    var lastMouseEvent = streaming.lastMouseEvent;\n\n    if (next <= now) {\n      // Draw only when animation is inactive\n      if (!chart.animating && !chart.tooltip._start) {\n        chart.draw();\n      }\n\n      if (lastMouseEvent) {\n        chart.eventHandler(lastMouseEvent);\n      }\n\n      streaming.lastDrawn = next + frameDuration > now ? next : now;\n    }\n  }\n\n  var StreamingPlugin = {\n    id: 'streaming',\n    beforeInit: function (chart) {\n      var streaming = chart.streaming = chart.streaming || {};\n      var canvas = streaming.canvas = chart.canvas;\n\n      var mouseEventListener = streaming.mouseEventListener = function (event) {\n        var pos = helpers$2.getRelativePosition(event, chart);\n        streaming.lastMouseEvent = {\n          type: 'mousemove',\n          chart: chart,\n          native: event,\n          x: pos.x,\n          y: pos.y\n        };\n      };\n\n      canvas.addEventListener('mousedown', mouseEventListener);\n      canvas.addEventListener('mouseup', mouseEventListener);\n    },\n    afterInit: function (chart) {\n      chart.update = update;\n\n      if (chart.resetZoom) {\n        Chart.Zoom.updateResetZoom(chart);\n      }\n    },\n    beforeUpdate: function (chart) {\n      var chartOpts = chart.options;\n      var scalesOpts = chartOpts.scales;\n\n      if (scalesOpts) {\n        scalesOpts.xAxes.concat(scalesOpts.yAxes).forEach(function (scaleOpts) {\n          if (scaleOpts.type === 'realtime' || scaleOpts.type === 'time') {\n            // Allow Bézier control to be outside the chart\n            chartOpts.elements.line.capBezierPoints = false;\n          }\n        });\n      }\n\n      return true;\n    },\n    afterUpdate: function (chart, options) {\n      var streaming = chart.streaming;\n      var pause = true; // if all scales are paused, stop refreshing frames\n\n      helpers$2.each(chart.scales, function (scale) {\n        if (scale instanceof RealTimeScale) {\n          pause &= helpers$2.valueOrDefault(scale.options.realtime.pause, options.pause);\n        }\n      });\n\n      if (pause) {\n        StreamingHelper.stopFrameRefreshTimer(streaming);\n      } else {\n        StreamingHelper.startFrameRefreshTimer(streaming, function () {\n          drawChart(chart);\n        });\n      }\n    },\n    beforeDatasetDraw: function (chart, args) {\n      var meta = args.meta;\n      var chartArea = chart.chartArea;\n      var clipArea = {\n        left: 0,\n        top: 0,\n        right: chart.width,\n        bottom: chart.height\n      };\n\n      if (meta.xAxisID && meta.controller.getScaleForId(meta.xAxisID) instanceof RealTimeScale) {\n        clipArea.left = chartArea.left;\n        clipArea.right = chartArea.right;\n      }\n\n      if (meta.yAxisID && meta.controller.getScaleForId(meta.yAxisID) instanceof RealTimeScale) {\n        clipArea.top = chartArea.top;\n        clipArea.bottom = chartArea.bottom;\n      }\n\n      canvasHelpers$1.clipArea(chart.ctx, clipArea);\n      return true;\n    },\n    afterDatasetDraw: function (chart) {\n      canvasHelpers$1.unclipArea(chart.ctx);\n    },\n    beforeEvent: function (chart, event) {\n      var streaming = chart.streaming;\n\n      if (event.type === 'mousemove') {\n        // Save mousemove event for reuse\n        streaming.lastMouseEvent = event;\n      } else if (event.type === 'mouseout') {\n        // Remove mousemove event\n        delete streaming.lastMouseEvent;\n      }\n\n      return true;\n    },\n    destroy: function (chart) {\n      var streaming = chart.streaming;\n      var canvas = streaming.canvas;\n      var mouseEventListener = streaming.mouseEventListener;\n      StreamingHelper.stopFrameRefreshTimer(streaming);\n      canvas.removeEventListener('mousedown', mouseEventListener);\n      canvas.removeEventListener('mouseup', mouseEventListener);\n      helpers$2.each(chart.scales, function (scale) {\n        if (scale instanceof RealTimeScale) {\n          scale.destroy();\n        }\n      });\n    }\n  };\n  var helpers$3 = Chart.helpers; // Ported from chartjs-plugin-zoom 0.7.0 3c187b7\n\n  var zoomNS = Chart.Zoom = Chart.Zoom || {}; // Ported from chartjs-plugin-zoom 0.7.0 3c187b7\n\n  zoomNS.zoomFunctions = zoomNS.zoomFunctions || {};\n  zoomNS.panFunctions = zoomNS.panFunctions || {}; // Ported from chartjs-plugin-zoom 0.7.0 3c187b7\n\n  function rangeMaxLimiter(zoomPanOptions, newMax) {\n    if (zoomPanOptions.scaleAxes && zoomPanOptions.rangeMax && !helpers$3.isNullOrUndef(zoomPanOptions.rangeMax[zoomPanOptions.scaleAxes])) {\n      var rangeMax = zoomPanOptions.rangeMax[zoomPanOptions.scaleAxes];\n\n      if (newMax > rangeMax) {\n        newMax = rangeMax;\n      }\n    }\n\n    return newMax;\n  } // Ported from chartjs-plugin-zoom 0.7.0 3c187b7\n\n\n  function rangeMinLimiter(zoomPanOptions, newMin) {\n    if (zoomPanOptions.scaleAxes && zoomPanOptions.rangeMin && !helpers$3.isNullOrUndef(zoomPanOptions.rangeMin[zoomPanOptions.scaleAxes])) {\n      var rangeMin = zoomPanOptions.rangeMin[zoomPanOptions.scaleAxes];\n\n      if (newMin < rangeMin) {\n        newMin = rangeMin;\n      }\n    }\n\n    return newMin;\n  }\n\n  function zoomRealTimeScale(scale, zoom, center, zoomOptions) {\n    var realtimeOpts = scale.options.realtime;\n    var streamingOpts = scale.chart.options.plugins.streaming;\n    var duration = helpers$3.valueOrDefault(realtimeOpts.duration, streamingOpts.duration);\n    var delay = helpers$3.valueOrDefault(realtimeOpts.delay, streamingOpts.delay);\n    var newDuration = duration * (2 - zoom);\n    var maxPercent, limitedDuration;\n\n    if (scale.isHorizontal()) {\n      maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n    } else {\n      maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n    }\n\n    if (zoom < 1) {\n      limitedDuration = rangeMaxLimiter(zoomOptions, newDuration);\n    } else {\n      limitedDuration = rangeMinLimiter(zoomOptions, newDuration);\n    }\n\n    realtimeOpts.duration = limitedDuration;\n    realtimeOpts.delay = delay + maxPercent * (duration - limitedDuration);\n  }\n\n  function panRealTimeScale(scale, delta, panOptions) {\n    var realtimeOpts = scale.options.realtime;\n    var streamingOpts = scale.chart.options.plugins.streaming;\n    var delay = helpers$3.valueOrDefault(realtimeOpts.delay, streamingOpts.delay);\n    var newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n\n    if (delta > 0) {\n      realtimeOpts.delay = rangeMaxLimiter(panOptions, newDelay);\n    } else {\n      realtimeOpts.delay = rangeMinLimiter(panOptions, newDelay);\n    }\n  }\n\n  zoomNS.zoomFunctions.realtime = zoomRealTimeScale;\n  zoomNS.panFunctions.realtime = panRealTimeScale;\n\n  function updateResetZoom(chart) {\n    // For chartjs-plugin-zoom 0.6.6 backward compatibility\n    var zoom = chart.$zoom || {\n      _originalOptions: {}\n    };\n    var resetZoom = chart.resetZoom;\n    var update = chart.update;\n\n    var resetZoomAndUpdate = function () {\n      helpers$3.each(chart.scales, function (scale) {\n        var realtimeOptions = scale.options.realtime;\n        var originalOptions = zoom._originalOptions[scale.id] || scale.originalOptions;\n\n        if (realtimeOptions) {\n          if (originalOptions) {\n            realtimeOptions.duration = originalOptions.realtime.duration;\n            realtimeOptions.delay = originalOptions.realtime.delay;\n          } else {\n            delete realtimeOptions.duration;\n            delete realtimeOptions.delay;\n          }\n        }\n      });\n      update.call(chart, {\n        duration: 0\n      });\n    };\n\n    chart.resetZoom = function () {\n      chart.update = resetZoomAndUpdate;\n      resetZoom();\n      chart.update = update;\n    };\n  }\n\n  zoomNS.updateResetZoom = updateResetZoom;\n  Chart.helpers.streaming = StreamingHelper;\n  Chart.plugins.register(StreamingPlugin);\n  return StreamingPlugin;\n});","map":null,"metadata":{},"sourceType":"script"}